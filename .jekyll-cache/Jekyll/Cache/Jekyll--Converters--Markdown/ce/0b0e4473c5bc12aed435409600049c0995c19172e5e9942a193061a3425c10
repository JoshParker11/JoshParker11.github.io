I"Á$<h2 id="intro">Intro</h2>

<p>There have been many times since I started my programming journey where it‚Äôs been made obvious to me how significant the hardware is to the programs we write. Being that all code is essentially a sequence of data transformations, the most important part of writing something that runs efficiently is having an understanding of what that data is, and precisely what we want to do with it. To figure out the best way to transform the data, one would imagine that knowing what is physically possible on a given piece of hardware would be a useful bit of information.</p>

<p>I have a general sense of things that helpful and harmful to this endeavor, but I‚Äôm nowhere near the level I‚Äôd like to be at. I stumbled upon an amazing <a href="https://www.nand2tetris.org/">website</a>/course called nand2tetris that starts from simple NAND gates and builds up chip by chip to a working simulated computer. This and a few other resources will comprise the bulk of the info I plan on consuming in this space. I will be working on this in parallel to the game engine series where I will be thinking about Intel‚Äôs architecture specifically, and will apply what I‚Äôm learning building my own architecture to problems I face there.</p>

<p>The motivation for building my own architecture from primitive blocks is to help build intuition for hardware architecture in a general, and really understand the consequences of each instruction I generate from code. Part of building intuition for a subject for me is teaching. Trying to go through the process of teaching someone else what I‚Äôm learning forces me to understand it at a deeper level, deep enough to explain WHY something is the way it is not just that it IS.</p>

<p>Hopefully documenting this process will be useful to someone some day, I don‚Äôt claim to be any sort of expert in this stuff, my goal is that the documenting the steps I take to get the understanding I‚Äôm after will help someone if they‚Äôre going down the same path.</p>

<h2 id="the-only-actual-hardware-well-talk-about">The Only ‚ÄúActual‚Äù Hardware We‚Äôll talk about</h2>

<p>Despite the entire point of this activity being to understand how the hardware works, I don‚Äôt actually want to be working with hardware or worrying about things in the domain of electrical engineering. I want to understand a small set of basic concepts that can get me to the NAND gate, and from there I will be doing everything in hardware simulations, and conceptual diagrams. I‚Äôve tried implementing some of this stuff on breadboards and it gets out hand VERY quickly.</p>

<h3 id="voltage">Voltage</h3>

<p><strong>Motivation:</strong> At it‚Äôs lowest level, the data in computer systems is expressed with a series of 1‚Äôs and 0‚Äôs, but that‚Äôs still essentially a software level concept. Computers don‚Äôt move around slips of paper with 1‚Äôs and 0‚Äôs written on them. So what is going on in the real world that we call 0 or 1?</p>

<p>Computers are electrical machines, so the fundamental unit is electricity, and we can make things happen by manipulating the flow of the current. So when we talk about binary (0 and 1), the physical correlation is a <strong>low voltage = 0</strong> and a <strong>high voltage = 1</strong>. Someone could give you a more formal definition of voltage, but for what I care about I just think about it as how much ‚Äújuice‚Äù or ‚Äúpower‚Äù is coming across a wire.</p>

<p><em>Little to no current flowing means the lightbulb won‚Äôt turn on (0)</em></p>

<p><img src="/assets/img/low_voltage.png" alt="Low Voltage" /></p>

<p><em>Enough current flowing and the lightbulb will turn on (1)</em></p>

<p><img src="/assets/img/high_voltage.png" alt="High Voltage" /></p>

<p>Something to note is that 0 and 1 don‚Äôt map directly to 0 volts and 1 volt, there is threshold where any voltage below a particular amount is ‚Äúlow‚Äù and any voltage above another amount is ‚Äúhigh‚Äù. I don‚Äôt think this is ubiquitous across platforms but a recurring set of values I saw were anything under 0.7-0.8 volts is considered ‚Äúlow‚Äù and anything above ~2 volts is ‚Äúhigh‚Äù.</p>

<p>The logic we want to eventually get to is <strong>bolean</strong> logic, where we are doing operations on a space of 2 values. There are many ways to refer to these values, and they get used interchangeably to some extent.</p>
<ul>
  <li>High / Low</li>
  <li>True / False</li>
  <li>Yes / No</li>
  <li>On / Off</li>
  <li>1 / 0</li>
  <li>‚Ä¶</li>
</ul>

<h3 id="transistors">Transistors</h3>

<p><em>add more info on why we need this</em></p>

<p>The transistor is the next thing I want to discuss. We know that we‚Äôre working with an electrical system, and that we need to control the current in our system to get variations in voltage, but how do we do that? You can think of a transistor as essentially a current switch, given an input of some voltage, we can ‚Äúturn on‚Äù the transistor and current can flow, otherwise current will not flow through. Let‚Äôs go over a quick diagram then we‚Äôll go into an example to show why we want this.</p>

<p><img src="/assets/img/transistor_base.png" alt="Transistor Off" /></p>

<p>This is a basic diagram of a transistor, don‚Äôt worry so much about the names, if we keep thinking about it in terms of a switch, the base is what turns the transistor ‚Äúon‚Äù or ‚Äúoff‚Äù, in the image below you can see that if we apply a bit of current through the base, we now allow a large current to pass over from the collector to the emitter. I think of it like pressing a button or flipping a switch, pressed/up the current flows, released/down the current does not flow.</p>

<p><img src="/assets/img/transistor_on.png" alt="Transistor On" /></p>

<p>I suspect that many people are probably in the ‚Äòwho cares?‚Äô camp at the moment, totally fair, this is certainly more info that you really need to get the level of understanding I was after. However, I have a hard time not digging down to the bottom of the well and a bit further just for good measure. So now you get to be subjected to it too :)</p>

<p>Let‚Äôs get to the main use for this knowledge for my purposes before I lose whoever‚Äôs left!</p>

<h3 id="hardware-nand">Hardware NAND</h3>

<p>what the heck is NAND</p>

<p>So I mentioned earlier one of the main resources I was looking at for information being called nand2tetris, I also mentioned that that was going to be the place where I left the land of hardware and electrical engineering and turned towards hardware simulation. But why NAND? What is it, and why do we want it? The short story is, a NAND gate is a logical operator where given an input of two binary values we will get an output of 0 if BOTH values are 1 and 1 in any other case. With this we can build every other logical operation we want from a series of NAND gates which we will be doing. As we string more and more together we gain higher and higher levels of expressivity, which we can use to build complex systems like a CPU.</p>

<p>As I mentioned NAND (short for Not And) is a boolean operator that operates on 0‚Äôs and 1‚Äôs. Since we are working in a boolean space there are a finite number of inputs and outputs, few enough where it‚Äôs fairly trivial to write out the entire set of possibilities. This is called a truth table, and the one for NAND looks like this.</p>

<p><img src="/assets/img/nand_truth.png" alt="NAND truth" /></p>

<p>We have our inputs A and B, and our output Out. For each permutation of possible values for A and B we can see what the output of the logical operation is. Again, note that the output is 0 or low if and only if both A and B are 1/high. This is the inverse of what AND would look like, where the output would be high only when both the inputs are high. That‚Äôs why this operation is NOT AND, it‚Äôs the output of AND but inverted.</p>

<p>We‚Äôll get into building other boolean operations shortly, but for now let‚Äôs check off the last bit of hardware understanding and apply our knowledge of transistors before we leave that space.</p>

<h3 id="hardware-layout">Hardware Layout</h3>

<p><img src="/assets/img/nmos_nand.png" alt="NMOS NAND" /></p>

<p>Here is the basic diagram describing one possible hardware implementation of a NAND gate, this one is using NMOS transistors (the things colored in blue), I just think about them in the way I described transistors previously. At the top of the diagram we have a 5volt (or some other higher voltage input) which passes through a resistor (we don‚Äôt really need to know a ton about resistors, basically the important part is that we drop the voltage from 5volts to something lower but still in the range we consider ‚Äúhigh‚Äù or 1), there‚Äôs a wire that goes out to the right which I‚Äôve labeled out to keep in line with our previous naming. Then there are two resistors who base connections from the transistor diagram are labeled A and B respectively (these are our inputs). Finally, the last symbol stands for ‚Äúground‚Äù and is a potential termination point for the circuit.</p>

<p>Let‚Äôs go through some examples of inputs to the system to see how this correlates to the truth table.</p>

<p>brief explanation of resistors</p>

<h2 id="where-to-now">Where to now?</h2>

<p>Why do we want nand? - can build everything from it</p>

<p>we will next discuss boolean logic, boolean functions, and make some of the other primitive gates from nand</p>
:ET